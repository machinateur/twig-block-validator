<?php
/*
 * MIT License
 *
 * Copyright (c) 2025 machinateur
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

declare(strict_types=1);

namespace Machinateur\TwigBlockValidator\Box\ProxyManager;

use Composer\Autoload\ClassLoader;
use Laminas\Code;
use Machinateur\TwigBlockValidator\Box\Twig\IsolatedTwigValidatorEnvironment;
use Machinateur\TwigBlockValidator\Twig\Extension\BlockValidatorExtension;
use Psr\EventDispatcher\EventDispatcherInterface;
use Twig\Extension\ExtensionInterface;

/**
 * A minimal proxy manager implementation that uses blueprints.
 */
class ProxyManager
{
    protected readonly string $workdir;

    public function __construct(
        // TODO: Add debug events where it makes sense.
        protected readonly EventDispatcherInterface $eventDispatcher,
        string                                      $cacheDir,
    ) {
        $this->workdir = $cacheDir.'/ProxyManager/Proxy';
    }

    /**
     * Initializes the class-loader once per process.
     *  Also ensures the current working directory for the proxy classes exists.
     */
    public function initClassLoader(): void
    {
        static $_classLoaderInitialized = false;

        if ( ! \file_exists($this->workdir)) {
            \mkdir($this->workdir, recursive: true);
        }

        if ($_classLoaderInitialized) {
            return;
        }

        // Add new namespace to autoloader.
        /** @var ClassLoader $_classLoader */
        global $_classLoader;
        $_classLoader->addPsr4(__NAMESPACE__.'\\Proxy\\', [ $this->workdir ], true);

        $_classLoaderInitialized = true;
    }

    /**
     * Generate a new proxy class instance that wraps the given object.
     *
     * @template T of ProxyGeneratorStrategyInterface
     *
     * @param class-string<T&ProxyStub>  $blueprint
     * @param object                     $object
     *
     * @throws \InvalidArgumentException when the blueprint class does not implement `ProxyGeneratorStrategyInterface`
     *
     * @return T    A fresh proxy instance.
     */
    public function createProxy(string $blueprint, object $object)
    {
        // Since this is super simplistic, we require the blueprint to be the generator strategy at the same time.
        if ( ! \is_subclass_of($blueprint, ProxyGeneratorStrategyInterface::class)) {
            throw new \InvalidArgumentException(\sprintf('Proxy blueprint must implement "%s".', ProxyGeneratorStrategyInterface::class));
        }

        // The classname cannot collide, if we use cache-key logic to sanitize it.
        $proxyClassName = IsolatedTwigValidatorEnvironment::getCacheKey($object::class.'Proxy', 'extensions');
        $proxyClassName = \substr($proxyClassName, \strrpos($proxyClassName, '\\') + 1);
        $proxyFileName  = $this->workdir.'/'.$proxyClassName.'.php';

        $proxyClass = Code\Generator\ClassGenerator::fromReflection(
            // Copy the proxy as base class.
            new Code\Reflection\ClassReflection($blueprint)
        );
        // Set name and namespace name.
        $proxyClass
            ->setName($proxyClassName)
            ->setNamespaceName(__NAMESPACE__.'\\Proxy')
        ;
        // Remove static method and proxy generator strategy.
        $proxyClass
            ->removeImplementedInterface(ProxyGeneratorStrategyInterface::class)
            ->removeMethod('generate');

        // Set file header and class.
        $proxyFile  = (new Code\Generator\FileGenerator)
            ->setDocBlock(
                new Code\Generator\DocBlockGenerator(\sprintf('Proxy for {@see %s} generated by `machinatuer/twig-block-validator`.', $object::class))
            )
            ->setClass($proxyClass)
        ;

        $proxyCode  = $blueprint::generate($object, $proxyClass, $proxyFile) ?? $proxyFile->generate();
        \assert(\is_string($proxyCode));

        if ( ! \file_exists($proxyFileName)
            || BlockValidatorExtension::hashFile($proxyFileName) !== BlockValidatorExtension::hash($proxyCode)
        ) {
            \file_put_contents($proxyFileName, $proxyCode, LOCK_EX);
        }

        // Load `\Isolated\Machinateur\TwigBlockValidator\Box\Twig\Extension\Proxy\$class` using the class loader (composer autoload).
        $className = $proxyClass->getNamespaceName().'\\'.$proxyClassName;
        if ( ! \class_exists($className, autoload: true)) {
            throw new \LogicException(\sprintf('The class "%s" does not exist (file "%s").', $className, $proxyFileName));
        }

        // The namespace path is added to the autoloader.
        $instance = new $className($object);
        \assert($instance instanceof ExtensionInterface);
        return $instance;
    }
}

if (false) {
    /**
     * A stub class for type-hints.
     */
    class ProxyStub implements ProxyGeneratorStrategyInterface
    {
        public function __construct(
            public  readonly object       $object,
            private readonly ProxyManager $proxyManager,
        ) {}

        public static function generate(object $object, Code\Generator\ClassGenerator $proxyClass, Code\Generator\FileGenerator $proxyFile): void
        {}
    }
}
